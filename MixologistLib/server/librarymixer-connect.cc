/****************************************************************
 *  Copyright 2010, Fair Use, Inc.
 *
 *  This file is part of the Mixologist.
 *
 *  The Mixologist is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  The Mixologist is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with the Mixologist; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 ****************************************************************/

#include <interface/librarymixer-connect.h>

#include <server/librarymixer-library.h>
#include <server/librarymixer-friendlibrary.h>

#include <pqi/pqinetwork.h>
#include <pqi/ownConnectivityManager.h>

#include <interface/settings.h>
#include <interface/peers.h> //for peers variable
#include <interface/iface.h> //for Control variable, librarymixerconnect

#include <QtGui>
#include <QDomDocument>
#include <QSettings>

const int BLOCKING_TRANSFER_TIMEOUT = 10000; //10 seconds

LibraryMixerConnect::LibraryMixerConnect()
    :email(""), password("") {
    http = new QHttp(this);

    connect(http, SIGNAL(requestFinished(int, bool)),
            this, SLOT(httpRequestFinishedSlot(int, bool)));
    connect(http, SIGNAL(sslErrors(QList<QSslError>)),
            this, SLOT(sslErrorsSlot(QList<QSslError>)));
    connect(http, SIGNAL(dataReadProgress(int,int)),
            this, SIGNAL(dataReadProgress(int,int)));
    connect(http, SIGNAL(authenticationRequired(const QString &, quint16, QAuthenticator *)),
            this, SLOT(slotAuthenticationRequired()));
}

void LibraryMixerConnect::setLogin(const QString &_email, const QString &_password) {
    QMutexLocker stack(&lmMutex);
    email = _email;
    password = _password;
}

void LibraryMixerConnect::setupModeAndHost(QString *host, QHttp::ConnectionMode *mode){
    QSettings settings(*startupSettings, QSettings::IniFormat);
    *host = settings.value("MixologyServer", DEFAULT_MIXOLOGY_SERVER).toString();

    if (email != "" || password != "") {
        http->setUser(email, password);
        *mode = QHttp::ConnectionModeHttps;
    } else *mode = QHttp::ConnectionModeHttp;

    if (host->compare(DEFAULT_MIXOLOGY_SERVER, Qt::CaseInsensitive) == 0){
        *host = DEFAULT_MIXOLOGY_SERVER_VALUE;
    }

    if (host->startsWith("http://")) {
        *mode = QHttp::ConnectionModeHttp;
        host->remove(0, 7);
    }
    if (host->startsWith("https://")){
        *mode = QHttp::ConnectionModeHttps;
        host->remove(0, 8);
    }
}

int LibraryMixerConnect::downloadXML(const QString &path, QIODevice *destination) {
    /* By default, the automatic header generated by QT using http->get sets HTTP keep-alive true.
       Instead, we use http->request so we can add our own header that specifies to close the connection.

       The reason for this is to correct an apparent bug in QHttp (which is deprecated and receiving no more updates).
       When connections were being kept alive, if the remote server closed the connection due to timeout, such as if any intermediate step
       took too long before the next transfer, such as a user looking at the tutorial for a while, or a step being debugged,
       or the server taking a while to read saved settings, QHttp would fail on subsequent transfers with Error 4: unexpected connection close.
       QHttp is supposed to automatically manage the connection in the background, but it would not rebuild it for the subsequent transfer,
       which would simply fail. */

    QHttpRequestHeader header("GET", path);
    header.setValue("Accept", "application/xml");
    header.setValue("Connection", "Close");

    QString host;
    QHttp::ConnectionMode mode;
    setupModeAndHost(&host, &mode);
    header.setValue("Host", host);

    if (email != "" || password != "") {
        http->setUser(email, password);
    }

    http->setHost(host, mode);

    httpGetId = http->request(header, 0, destination);
    return httpGetId;
}

int LibraryMixerConnect::downloadVersion(qlonglong current) {
    QMutexLocker stack(&lmMutex);
    buffer = new QBuffer();
    if (!buffer->open(QIODevice::ReadWrite)) return -1;
    QString url = "/api/mixologist_version?current=";
    url.append(QString::number(current));
    version_check_id = downloadXML(url, buffer);
    return version_check_id;
}

int LibraryMixerConnect::downloadInfo() {
    QMutexLocker stack(&lmMutex);
    buffer = new QBuffer();
    if (!buffer->open(QIODevice::ReadWrite)) return -1;
    info_download_id = downloadXML("/api/user?id=&name=&checkout_link1=&contact_link1=&link_title1=&checkout_link2=&contact_link2=&link_title2=&checkout_link3=&contact_link3=&link_title3=&library=&libraryonlycheckout=true&librarypaginate=-1",
                                   buffer);
    return info_download_id;
}

int LibraryMixerConnect::downloadLibrary(bool blocking) {
    bool doBlocking = false;
    QMutexLocker stack(&lmMutex);
    if (lastLibraryUpdate.isNull() || lastLibraryUpdate.secsTo(QDateTime::currentDateTime()) > CONNECT_COOLDOWN) {
        lastLibraryUpdate = QDateTime::currentDateTime();
        buffer = new QBuffer();
        if (!buffer->open(QIODevice::ReadWrite)) return -1;
        if (blocking) {
            doneTransfer = false;
            doBlocking = true;
        }
        library_download_id = downloadXML("/api/user?library=&libraryonlycheckout=true&librarypaginate=-1", buffer);

        if (!doBlocking) return library_download_id;
    }
    if (doBlocking) {
        doneTransfer = false;
        QTimer::singleShot(BLOCKING_TRANSFER_TIMEOUT, this, SLOT(blockingTimeOut()));
        while (!doneTransfer) {
            qApp->processEvents(QEventLoop::WaitForMoreEvents);
        }
        return 0;
    }
    return -1;
}

int LibraryMixerConnect::downloadFriends(bool blocking) {
    bool doBlocking = false;
    {
        QMutexLocker stack(&lmMutex);
        if (lastFriendUpdate.isNull() || lastFriendUpdate.secsTo(QDateTime::currentDateTime()) > CONNECT_COOLDOWN) {
            lastFriendUpdate = QDateTime::currentDateTime();
            buffer = new QBuffer();
            if (!buffer->open(QIODevice::ReadWrite)) return -1;
            if (blocking) {
                doneTransfer = false;
                doBlocking = true;
            }
            friend_download_id = downloadXML("/api/friends?name=&id=&scratch[Mixology_Public_Key]=&scratch[Mixology_Local_IP]=&scratch[Mixology_Local_Port]=&scratch[Mixology_External_IP]=&scratch[Mixology_External_Port]=",
                                             buffer);
            if (!doBlocking) return friend_download_id;
        }
    }
    if (doBlocking) {
        QTimer::singleShot(BLOCKING_TRANSFER_TIMEOUT, this, SLOT(blockingTimeOut()));
        while (!doneTransfer) {
            qApp->processEvents(QEventLoop::WaitForMoreEvents);
        }
        return 0;
    }

    return -1;
}

int LibraryMixerConnect::downloadFriendsLibrary() {
    QMutexLocker stack(&lmMutex);
    if (lastFriendLibraryUpdate.isNull() || lastFriendLibraryUpdate.secsTo(QDateTime::currentDateTime()) > CONNECT_COOLDOWN) {
        lastFriendLibraryUpdate = QDateTime::currentDateTime();
        buffer = new QBuffer();
        if (!buffer->open(QIODevice::ReadWrite)) return -1;
        friend_library_download_id = downloadXML("/api/library?excludeself=&onlycheckout=",
                                                 buffer);
        return friend_library_download_id;
    }
    return -1;
}

int LibraryMixerConnect::uploadXML(const QString &path,
                                   QIODevice *source,
                                   QIODevice *destination) {

    QHttpRequestHeader header("POST", path);
    header.setValue("Accept", "application/xml");
    header.setValue("content-type", "application/xml");
    header.setValue("Connection", "Close");

    QString host;
    QHttp::ConnectionMode mode;
    setupModeAndHost(&host, &mode);
    header.setValue("Host", host);
    if (email != "" && password != "") {
        QString credentials;
        credentials = email + ":" + password;
        header.setValue( "Authorization", QString("Basic ").append(credentials.toLatin1().toBase64()));
    }

    http->setHost(host, mode);

    httpGetId = http->request(header, source, destination);

    return httpGetId;
}

int LibraryMixerConnect::uploadInfo(const int link_to_set, const QString &public_key) {
    QMutexLocker stack(&lmMutex);
    buffer = new QBuffer();
    if (!buffer->open(QIODevice::ReadWrite)) return -1;
    uploadBuffer = new QBuffer();
    if (!uploadBuffer->open(QIODevice::ReadWrite)) return -1;

    /* We cannot simply perform an ordinary post using &key=value syntax because
       the public key may contain + characters. */
    uploadBuffer->write("<user>");
    if (link_to_set != -1) {
        uploadBuffer->write("<standard_link" + QByteArray::number(link_to_set) + ">");
        uploadBuffer->write(MIXOLOGY_LINK_TITLE);
        uploadBuffer->write("</standard_link" + QByteArray::number(link_to_set) + ">");
    }
    uploadBuffer->write("<scratch>");
    uploadBuffer->write("<Mixology_Public_Key>");
    uploadBuffer->write(public_key.toLatin1());
    uploadBuffer->write("</Mixology_Public_Key>");
    uploadBuffer->write("</scratch>");
    uploadBuffer->write("</user>");

    uploadBuffer->seek(0);

    info_upload_id = uploadXML("/api/edit_user", uploadBuffer, buffer);
    return info_upload_id;
}

int LibraryMixerConnect::uploadAddress(const QString &localIP, ushort localPort, const QString &externalIP, ushort externalPort) {
    QMutexLocker stack(&lmMutex);
    buffer = new QBuffer();
    if (!buffer->open(QIODevice::ReadWrite)) return -1;
    uploadBuffer = new QBuffer();
    if (!uploadBuffer->open(QIODevice::ReadWrite)) return -1;

    uploadBuffer->write("<user>");
    uploadBuffer->write("<scratch>");
    uploadBuffer->write("<Mixology_Local_IP>");
    uploadBuffer->write(localIP.toUtf8());
    uploadBuffer->write("</Mixology_Local_IP>");
    uploadBuffer->write("<Mixology_Local_Port>");
    uploadBuffer->write(QByteArray::number(localPort));
    uploadBuffer->write("</Mixology_Local_Port>");
    uploadBuffer->write("<Mixology_External_IP>");
    if (externalIP.isEmpty())
        uploadBuffer->write("[[set_ip]]");
    else
        uploadBuffer->write(externalIP.toUtf8());
    uploadBuffer->write("</Mixology_External_IP>");
    uploadBuffer->write("<Mixology_External_Port>");
    uploadBuffer->write(QByteArray::number(externalPort));
    uploadBuffer->write("</Mixology_External_Port>");
    uploadBuffer->write("</scratch>");
    uploadBuffer->write("</user>");

    uploadBuffer->seek(0);

    address_upload_id = uploadXML("/api/edit_user", uploadBuffer, buffer);
    return address_upload_id;
}

void LibraryMixerConnect::httpRequestFinishedSlot(int requestId, bool error) {
    QMutexLocker stack(&lmMutex);
    if (requestId != httpGetId) return; //skip request completions that aren't related to actual http requests
    if (requestId == version_check_id) {
        if (error) goto versionDownloadError;

        qulonglong version = 0;
        QString description("");
        QString importance("Recommended");

        QDomDocument xml;
        buffer->seek(0);
        if (!xml.setContent(buffer)) goto versionDownloadError;
        buffer->deleteLater();
        QDomElement rootNode = xml.documentElement();
        if (rootNode.tagName() != "versions" ) goto versionDownloadError;
        if (rootNode.firstChildElement("version").firstChildElement("number").isNull()) {
            emit downloadedVersion(1, "", ""); //Version is up to date if there are no version elements
            return;
        }
        version = rootNode.firstChildElement("version").firstChildElement("number").text().toLongLong();
        for (QDomElement versionNode = rootNode.firstChildElement();
                !versionNode.isNull();
                versionNode = versionNode.nextSiblingElement()) {

            if (versionNode.firstChildElement("number").isNull()) goto versionDownloadError;
            if (versionNode.firstChildElement("description").isNull()) goto versionDownloadError;
            if (versionNode.firstChildElement("importance").isNull()) goto versionDownloadError;
            description.append(versionNode.firstChildElement("number").text());
            description.append(":\n");
            description.append(versionNode.firstChildElement("description").text());
            description.append("\n\n");
            if (versionNode.firstChildElement("importance").text() == "Essential") importance = "Essential";
        }

        emit downloadedVersion(version, description, importance);
        return;
    } else if (requestId == info_download_id) {
        if (error) goto infoDownloadError;

        QDomDocument xml;
        buffer->seek(0);
        if (!xml.setContent(buffer)) goto infoDownloadError;
        buffer->deleteLater();
        QDomElement rootNode = xml.documentElement();
        if (rootNode.tagName() != "user" ) goto infoDownloadError;
        QDomElement idNode = rootNode.firstChildElement("id");
        if (idNode.isNull()) goto infoDownloadError;
        QDomElement nameNode = rootNode.firstChildElement("name");
        if (nameNode.isNull()) goto infoDownloadError;
        QDomElement checkout1Node = rootNode.firstChildElement("checkout_link1");
        if (checkout1Node.isNull()) goto infoDownloadError;
        QDomElement contact1Node = rootNode.firstChildElement("contact_link1");
        if (contact1Node.isNull()) goto infoDownloadError;
        QDomElement title1Node = rootNode.firstChildElement("link_title1");
        if (title1Node.isNull()) goto infoDownloadError;
        QDomElement checkout2Node = rootNode.firstChildElement("checkout_link2");
        if (checkout2Node.isNull()) goto infoDownloadError;
        QDomElement contact2Node = rootNode.firstChildElement("contact_link2");
        if (contact2Node.isNull()) goto infoDownloadError;
        QDomElement title2Node = rootNode.firstChildElement("link_title2");
        if (title2Node.isNull()) goto infoDownloadError;
        QDomElement checkout3Node = rootNode.firstChildElement("checkout_link3");
        if (checkout3Node.isNull()) goto infoDownloadError;
        QDomElement contact3Node = rootNode.firstChildElement("contact_link3");
        if (contact3Node.isNull()) goto infoDownloadError;
        QDomElement title3Node = rootNode.firstChildElement("link_title3");
        if (title3Node.isNull()) goto infoDownloadError;
        QDomElement libraryNode = rootNode.firstChildElement("library");
        if (libraryNode.isNull()) goto infoDownloadError;

        emit downloadedInfo(nameNode.text(), idNode.text().toInt(),
                            checkout1Node.text(), contact1Node.text(), title1Node.text(),
                            checkout2Node.text(), contact2Node.text(), title2Node.text(),
                            checkout3Node.text(), contact3Node.text(), title3Node.text(),
                            libraryNode);
        return;
    } else if (requestId == info_upload_id) {
        if (error) goto infoUploadError;

        QDomDocument xml;
        QDomDocument uploaded_xml;
        buffer->seek(0);
        uploadBuffer->seek(0);
        if (!xml.setContent(buffer)) goto infoUploadError;
        if (!uploaded_xml.setContent(uploadBuffer)) goto infoUploadError;
        buffer->deleteLater();
        uploadBuffer->deleteLater();
        QDomElement rootNode = xml.documentElement();
        QDomElement uploaded_rootNode = uploaded_xml.documentElement();
        if (rootNode.tagName() != "user" ) goto infoUploadError;
        if (uploaded_rootNode.tagName() != "user" ) goto infoUploadError;

        QDomElement scratchNode = rootNode.firstChildElement("scratch");
        if (scratchNode.isNull()) goto infoUploadError;
        QDomElement uploaded_scratchNode = uploaded_rootNode.firstChildElement("scratch");
        if (uploaded_scratchNode.isNull()) goto infoUploadError;

        QDomElement publicNode = scratchNode.firstChildElement("Mixology_Public_Key");
        QDomElement uploaded_publicNode = uploaded_scratchNode.firstChildElement("Mixology_Public_Key");
        if (publicNode.isNull()) goto infoUploadError;
        if (uploaded_publicNode.isNull()) goto infoUploadError;
        if (publicNode.text() != uploaded_publicNode.text()) goto infoUploadError;

        emit uploadedInfo();
        return;
    } else if (requestId == friend_download_id) {
        if (error) goto friendDownloadError;

        QDomDocument xml;
        buffer->seek(0);
        if (!xml.setContent(buffer)) goto friendDownloadError;
        buffer->deleteLater();
        QDomElement rootNode = xml.documentElement();
        if (rootNode.tagName() != "friends" ) goto friendDownloadError;
        for (QDomElement friendNode = rootNode.firstChildElement("user");
                !friendNode.isNull();
                friendNode = friendNode.nextSiblingElement("user")) {

            QString local_ip, external_ip;
            QString name, certificate;
            unsigned int librarymixer_id;
            ushort local_port, external_port;

            if (!friendNode.firstChildElement("name").isNull()) {
                name = friendNode.firstChildElement("name").text();
            } else goto friendDownloadError;
            if (!friendNode.firstChildElement("id").isNull()) {
                librarymixer_id = friendNode.firstChildElement("id").text().toInt();
            } else goto friendDownloadError;
            if (!friendNode.firstChildElement("scratch").firstChildElement("Mixology_Local_IP").isNull()) {
                local_ip = friendNode.firstChildElement("scratch").firstChildElement("Mixology_Local_IP").text();
            } else goto friendDownloadError;
            if (!friendNode.firstChildElement("scratch").firstChildElement("Mixology_Local_Port").isNull()) {
                local_port = friendNode.firstChildElement("scratch").firstChildElement("Mixology_Local_Port").text().toUShort();
            } else goto friendDownloadError;
            if (!friendNode.firstChildElement("scratch").firstChildElement("Mixology_External_IP").isNull()) {
                external_ip = friendNode.firstChildElement("scratch").firstChildElement("Mixology_External_IP").text();
            } else goto friendDownloadError;
            if (!friendNode.firstChildElement("scratch").firstChildElement("Mixology_External_Port").isNull()) {
                external_port = friendNode.firstChildElement("scratch").firstChildElement("Mixology_External_Port").text().toUShort();
            } else goto friendDownloadError;
            if (!friendNode.firstChildElement("scratch").firstChildElement("Mixology_Public_Key").isNull()) {
                certificate = friendNode.firstChildElement("scratch").firstChildElement("Mixology_Public_Key").text();
            } else goto friendDownloadError;

            peers->addUpdateFriend(librarymixer_id, certificate, name, local_ip, local_port, external_ip, external_port);
            //For now, we are doing nothing to remove already connected friends that have been removed on LibraryMixexr
        }
        emit downloadedFriends();
        doneTransfer = true;
        return;
    } else if (requestId == friend_library_download_id) {
        if (error) goto friendLibraryDownloadError;

        QDomDocument xml;
        buffer->seek(0);
        if (!xml.setContent(buffer)) goto friendLibraryDownloadError;
        buffer->deleteLater();
        QDomElement rootNode = xml.documentElement();
        if (rootNode.tagName() != "library" ) goto friendLibraryDownloadError;

        libraryMixerFriendLibrary->mergeLibrary(rootNode);

        emit downloadedFriendsLibrary();

        return;
    } else if (requestId == library_download_id) {
        if (error) goto libraryDownloadError;
        QDomDocument xml;
        buffer->seek(0);
        if (!xml.setContent(buffer)) goto infoDownloadError;
        buffer->deleteLater();
        QDomElement rootNode = xml.documentElement();
        QDomElement libraryNode = rootNode.firstChildElement("library");
        if (libraryNode.isNull()) goto infoDownloadError;

        librarymixermanager->mergeLibrary(libraryNode);

        emit downloadedLibrary();
        doneTransfer = true;
        return;
    } else if (requestId == address_upload_id) {
        if (error) goto addressUploadError;

        QDomDocument xml;
        QDomDocument uploaded_xml;
        buffer->seek(0);
        uploadBuffer->seek(0);
        if (!xml.setContent(buffer)) goto addressUploadError;
        if (!uploaded_xml.setContent(uploadBuffer)) goto addressUploadError;
        buffer->deleteLater();
        uploadBuffer->deleteLater();
        QDomElement rootNode = xml.documentElement();
        QDomElement uploaded_rootNode = uploaded_xml.documentElement();
        if (rootNode.tagName() != "user" ) goto addressUploadError;
        if (uploaded_rootNode.tagName() != "user" ) goto addressUploadError;

        QDomElement scratchNode = rootNode.firstChildElement("scratch");
        if (scratchNode.isNull()) goto addressUploadError;
        QDomElement uploaded_scratchNode = uploaded_rootNode.firstChildElement("scratch");
        if (uploaded_scratchNode.isNull()) goto addressUploadError;

        QDomElement localIPNode = scratchNode.firstChildElement("Mixology_Local_IP");
        QDomElement uploaded_localIPNode = uploaded_scratchNode.firstChildElement("Mixology_Local_IP");
        if (localIPNode.isNull()) goto addressUploadError;
        if (uploaded_localIPNode.isNull()) goto addressUploadError;
        if (localIPNode.text() != uploaded_localIPNode.text()) goto addressUploadError;

        QDomElement localPortNode = scratchNode.firstChildElement("Mixology_Local_Port");
        QDomElement uploaded_localPortNode = uploaded_scratchNode.firstChildElement("Mixology_Local_Port");
        if (localPortNode.isNull()) goto addressUploadError;
        if (uploaded_localPortNode.isNull()) goto addressUploadError;
        if (localPortNode.text() != uploaded_localPortNode.text()) goto addressUploadError;

        QDomElement externalIPNode = scratchNode.firstChildElement("Mixology_External_IP");
        QDomElement uploaded_externalIPNode = uploaded_scratchNode.firstChildElement("Mixology_External_IP");
        if (externalIPNode.isNull()) goto addressUploadError;
        if (uploaded_externalIPNode.isNull()) goto addressUploadError;
        if (uploaded_externalIPNode.text() == "[[set_ip]]") {
            ownConnectivityManager->setFallbackExternalIP(externalIPNode.text());
        } else {
            if (externalIPNode.text() != uploaded_externalIPNode.text()) goto addressUploadError;
        }

        QDomElement externalPortNode = scratchNode.firstChildElement("Mixology_External_Port");
        QDomElement uploaded_externalPortNode = uploaded_scratchNode.firstChildElement("Mixology_External_Port");
        if (externalPortNode.isNull()) goto addressUploadError;
        if (uploaded_externalPortNode.isNull()) goto addressUploadError;
        if (externalPortNode.text() != uploaded_externalPortNode.text()) goto addressUploadError;

        emit uploadedAddress();
        return;
    }
versionDownloadError:
    handleErrorReceived(version_download_error);
    return;
infoDownloadError:
    handleErrorReceived(info_download_error);
    return;
infoUploadError:
    handleErrorReceived(info_upload_error);
    return;
friendDownloadError:
    handleErrorReceived(friend_download_error);
    return;
friendLibraryDownloadError:
    handleErrorReceived(friend_library_download_error);
    return;
libraryDownloadError:
    handleErrorReceived(library_download_error);
    return;
addressUploadError:
    handleErrorReceived(address_upload_error);
}

void LibraryMixerConnect::handleErrorReceived(int error) {
    buffer->deleteLater();
    if (httpGetId == info_upload_id || httpGetId == address_upload_id)
        uploadBuffer->deleteLater();
    emit(errorReceived(error));
}

void LibraryMixerConnect::sslErrorsSlot(const QList<QSslError> &errors) {
    QMutexLocker stack(&lmMutex);
    /* Fix for the weird erroneous QSslErrors set to NoError that showed up after upgrading to OpenSSL 1.0.0a
       from the old custom Retroshare version */
    bool realError = false;
    foreach (const QSslError &error, errors) {
        if (error.error() != QSslError::NoError) {
            realError = true;
            break;
        }
    }
    if (realError) {
        buffer->deleteLater();
        if (httpGetId == info_upload_id) uploadBuffer->deleteLater(); //it seems like there should be a better way
        emit(errorReceived(ssl_error));
    } else {
        http->ignoreSslErrors();
    }
}

void LibraryMixerConnect::slotAuthenticationRequired() {
    QMutexLocker stack(&lmMutex);
    http->abort();
    handleErrorReceived(bad_login_error);
}

void LibraryMixerConnect::blockingTimeOut() {
    QMutexLocker stack(&lmMutex);
    doneTransfer = true;
}
